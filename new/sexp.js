// generated by pjs -- do not edit
var symlib = require("./symbol.js");
var sym = symlib.get;
var symbolRE = new RegExp("(" + "[a-zA-Z_][a-zA-Z_.0-9]*" + "|" + "[a-zA-Z_.\\[\\]0-9&!=|+<>#{}*-]+" + ")|.", "g");

function reMatchOfs(re, str, ofs) {
  re.lastIndex = ofs;
  var match = re.exec(str);
  if (!match || !match[1]) {
    return null;
  }
  return match[1];
}

function isNumber(atom) {
  var re = new RegExp("^\\d+$");
  return re.test(atom);
}

function Reader(str) {
  this.str = str;
  this.ofs = 0;
  this.lineOfs = 0;
  this.line = 1;
}
Reader.prototype.pos = function(out) {
  if (!out) {
    out = {};
  }
  out.line = this.line;
  out.col = this.ofs - this.lineOfs;
  return out;
};
Reader.prototype.errorAtPoint = function() {
  var message = [].join.call(arguments, "");
  var pos = this.pos();
  return new Error(message + " at " + pos.line + ":" + pos.col);
};
Reader.prototype.readQuote = function() {
  var str = "";
  var open = this.str[this.ofs];
  ++this.ofs;
  var close;
  switch (open) {
    case "<":
      close = ">";
      break;
    default:
      close = open;
      break;
  }
  for (; this.ofs < this.str.length; ++this.ofs) {
    var c = this.str[this.ofs];
    if (c == close) {
      break;
    }
    str += c;
  }
  var actualClose = this.str[this.ofs];
  if (close != actualClose) {
    throw this.errorAtPoint("expected end of quote ", close, ", got ", actualClose);
  }
  ++this.ofs;
  return str;
};
Reader.prototype.read = function() {
  while (this.ofs < this.str.length) {
    var c = this.str[this.ofs];
    ++this.ofs;
    switch (c) {
      case " ":
        continue;
      case "\n":
        ++this.line;
        this.lineOfs = this.ofs + 1;
        continue;
      case ";":
        for (; this.ofs < this.str.length; ++this.ofs) {
          if (this.str[this.ofs] == "\n") {
            break;
          }
        }
        continue;
      case "(":
        var sexp = [];
        this.pos(sexp);
        for (var s;
          (s = this.read()) != null;) {
          sexp.push(s);
        }
        if (this.str[this.ofs] != ")") {
          throw "expected rparen";
        }
        ++this.ofs;
        return sexp;
      case ")":
        --this.ofs;
        return null;
      case "\x22":
        --this.ofs;
        return this.readQuote();
      case "`":
        return [sym("`"), this.read()];
      case ",":
        if (this.str[this.ofs] == "@") {
          ++this.ofs;
          return [sym(",@"), this.read()];
        }
        return [sym(","), this.read()];
      case ":":
        var symbol = this.read();
        return [sym("pjs.sym"), symlib.str(symbol)];
      case "#":
        var quoter = this.read();
        var text = this.readQuote();
        return [sym("#"), quoter, text];
      default:
        --this.ofs;
        var atom = reMatchOfs(symbolRE, this.str, this.ofs);
        if (!atom) {
          var pos = this.pos();
          throw this.errorAtPoint("bad char ", c);
        }
        this.ofs += atom.length;
        if (isNumber(atom)) {
          return parseInt(atom);
        } else {
          return sym(atom);
        }
    }
    throw "shouldn't be reached";
  }
  return null;
};

function parse(data) {
  var r = new Reader("(" + data.toString() + ")");
  return r.read();
}
exports.parse = parse;
exports.Reader = Reader;
