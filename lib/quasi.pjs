;; Copyright 2015 Google Inc. All Rights Reserved.
;;
;; Licensed under the Apache License, Version 2.0 (the "License");
;; you may not use this file except in compliance with the License.
;; You may obtain a copy of the License at
;;
;;     http://www.apache.org/licenses/LICENSE-2.0
;;
;; Unless required by applicable law or agreed to in writing, software
;; distributed under the License is distributed on an "AS IS" BASIS,
;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;; See the License for the specific language governing permissions and
;; limitations under the License.

(function isSplice (sexp)
  (return (&& (== sexp.length 2)
              (pjs.isSym (at sexp 0) ",@"))))

(function qq (sexp)
  (return
   (caseSexp sexp
     (symbol (return (list :pjs.sym (pjs.symStr sexp))))
     (number (return sexp))
     (string (return sexp))
     (sexp
      (do
        (if (== sexp.length 2)
          (do
            (if (pjs.isSym (at sexp 0) ",")
              (return (at sexp 1)))
            (if (pjs.isSym (at sexp 0) ",@")
              (throw (new Error "no uqs here")))))
        (var parts [])
        (var cur null)
        (var didSplice false)
        (sexp.forEach (function (s)
                        (if (isSplice s)
                          (do
                            (= didSplice true)
                            (parts.push (at s 1))
                            (= cur null))
                          (do
                            (if (! cur)
                              (do
                                (= cur `(list))
                                (parts.push cur)))
                            (cur.push (qq.call cur s))))))
        ;; If there are no splices, parts has only one entry that we
        ;; can return.
        ;;   (list 1 2 3)
        ;; If there is a splice of x, we want to return code that concats
        ;; the parts list:
        ;;   ([].concat.apply [] ...).
        (if didSplice
          (do
            (parts.unshift :list)
            (return `([].concat.apply [] ,parts)))
          (return (at parts 0))))))))

(= exports.qq qq)
